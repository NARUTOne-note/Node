# 数据库 & 服务操作

1. 数据持久化 - 将数据保存到能够长久保存数据的存储介质中，在掉电的情况下数据也不会丢失。
2. 数据库发展史 - 网状数据库、层次数据库、关系数据库、NoSQL 数据库、NewSQL 数据库。
3. 关系数据库特点。

- 理论基础：**关系代数**（集合论、一阶谓词、关系运算）。
- 具体表象：用**二维表**（有行和列）组织数据。
- 编程语言：**结构化查询语言**（SQL）。
      - DDL：数据定义语言
      - DML：数据操作语言
      - DCL：数据控制语言
      - TCL：事务控制语言

4. **ER模型**，全称为**实体关系模型**（Entity-Relationship Model）
5. 关系数据库产品：oracle、db2、sql server、mysql、postgresql

## mysql

[mysql 基础教程](https://www.runoob.com/mysql/mysql-administration.html)

window环境命令：

```bash
# 启动
net start mysql
# 关闭
net stop mysql

# 连接, 本地
mysql -u root -p

# databases
show databases;
use [database_name];
# tables
show tables;
```

### mysql 性能优化

使用基本原则

1、只存储，不计算
2、尽量单表查询，不跨表和多表关联
3、杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手
    - 大事务：运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。
    - 大 SQL：复杂的SQL意味着过多的表的关联，MySQL 数据库处理关联超过3张表以上的SQL时，占用资源多，性能低下。
    - 大批量：多条SQL一次性执行完成，可以减少一条条执行SQL产生的额外开销，但必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。
    - 大字段：blob、text类型的大字段要尽量少用，必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。

建表：
1、尽量给每个字段都加上“not null”约束或者设置合理的默认值约束
2、 每个列都必须添加`comment`注释
3、单张表的字段数尽量空值在50个字段以内，如果字段过多可以考虑垂直拆分
4、大文件不应该使用`blob`类型而是保存它们的路径，`blob`和`text`这样的类型会导致处理性能下降，全表扫描代价大大增加。
5、对货币等对精度敏感的数据，应该使用定点数（`decimal`）而不是浮点数（`float`）。

## SQL

1、**DDL**（数据定义语言），主要用于创建、删除、修改数据库中的对象，比如创建、删除和修改二维表，核心的关键字包括`create`、`drop`和`alter`
2、**DML**（数据操作语言），主要负责数据的插入、删除、更新和查询，关键词包括`insert`、`delete`、`update`和`select`
3、**DCL**（数据控制语言），用于授予和召回权限，核心关键词是`grant`和`revoke`
4、**TCL**（事务控制语言），通常用于事务控制

**SELECT**查询语句:

1、MySQL目前的版本不支持全外连接，上面我们通过`union`操作，将左外连接和右外连接的结果求并集实现全外连接的效果。
2. MySQL 中支持多种类型的运算符，包括：算术运算符（`+`、`-`、`*`、`/`、`%`）、比较运算符（`=`、`<>`、`<=>`、`<`、`<=`、`>`、`>=`、`BETWEEN...AND..`.、`IN`、`IS NULL`、`IS NOT NULL`、`LIKE`、`RLIKE`、`REGEXP`）、逻辑运算符（`NOT`、`AND`、`OR`、`XOR`）和位运算符（`&`、`|`、`^`、`~`、`>>`、`<<`），我们可以在 DML 中使用这些运算符处理数据。
3. 在查询数据时，可以在`SELECT`语句及其子句（如`WHERE`子句、`ORDER BY`子句、`HAVING`子句等）中使用函数，这些函数包括字符串函数、数值函数、时间日期函数、流程函数等，如下面的表格所示。

- where：查询条件，比如 where id=1
- as：别名，比如 select xxx as 'yyy'
- and: 连接多个条件
- in/not in：集合查找，比如 where a in (1,2)
- between and：区间查找，比如 where a between 1 and 10
- limit：分页，比如 limit 0,5
- order by：排序，可以指定先根据什么升序、如果相等再根据什么降序，比如 order by a desc,b asc
- group by：分组，比如 group by aaa
- having：分组之后再过滤，比如 group by aaa having xxx > 5
- distinct：去重

常用字符串函数。

   | 函数                        | 功能                                                  |
   | --------------------------- | ----------------------------------------------------- |
   | `CONCAT`                    | 将多个字符串连接成一个字符串                          |
   | `FORMAT`                    | 将数值格式化成字符串并指定保留几位小数                |
   | `FROM_BASE64` / `TO_BASE64` | BASE64解码/编码                                       |
   | `BIN` / `OCT` / `HEX`       | 将数值转换成二进制/八进制/十六进制字符串              |
   | `LOCATE`                    | 在字符串中查找一个子串的位置                          |
   | `LEFT` / `RIGHT`            | 返回一个字符串左边/右边指定长度的字符                 |
   | `LENGTH` / `CHAR_LENGTH`    | 返回字符串的长度以字节/字符为单位                     |
   | `LOWER` / `UPPER`           | 返回字符串的小写/大写形式                             |
   | `LPAD` / `RPAD`             | 如果字符串的长度不足，在字符串左边/右边填充指定的字符 |
   | `LTRIM` / `RTRIM`           | 去掉字符串前面/后面的空格                             |
   | `ORD` / `CHAR`              | 返回字符对应的编码/返回编码对应的字符                 |
   | `STRCMP`                    | 比较字符串，返回-1、0、1分别表示小于、等于、大于      |
   | `SUBSTRING`                 | 返回字符串指定范围的子串                              |

   常用数值函数。

   | 函数                                                     | 功能                               |
   | -------------------------------------------------------- | ---------------------------------- |
   | `ABS`                                                    | 返回一个数的绝度值                 |
   | `CEILING` / `FLOOR`                                      | 返回一个数上取整/下取整的结果      |
   | `CONV`                                                   | 将一个数从一种进制转换成另一种进制 |
   | `CRC32`                                                  | 计算循环冗余校验码                 |
   | `EXP` / `LOG` / `LOG2` / `LOG10`                         | 计算指数/对数                      |
   | `POW`                                                    | 求幂                               |
   | `RAND`                                                   | 返回[0,1)范围的随机数              |
   | `ROUND`                                                  | 返回一个数四舍五入后的结果         |
   | `SQRT`                                                   | 返回一个数的平方根                 |
   | `TRUNCATE`                                               | 截断一个数到指定的精度             |
   | `SIN` / `COS` / `TAN` / `COT` / `ASIN` / `ACOS` / `ATAN` | 三角函数                           |

   常用时间日期函数。

   | 函数                                      | 功能                                  |
   | ----------------------------------------- | ------------------------------------- |
   | `CURDATE` / `CURTIME` / `NOW`             | 获取当前日期/时间/日期和时间          |
   | `ADDDATE` / `SUBDATE`                     | 将两个日期表达式相加/相减并返回结果   |
   | `DATE` / `TIME`                           | 从字符串中获取日期/时间               |
   | `YEAR` / `MONTH` / `DAY`                  | 从日期中获取年/月/日                  |
   | `HOUR` / `MINUTE` / `SECOND`              | 从时间中获取时/分/秒                  |
   | `DATEDIFF` / `TIMEDIFF` / `TIMESTAMPDIFF` | 返回两个时间日期表达式相差多少天/小时 |
   | `MAKEDATE` / `MAKETIME`                   | 制造一个日期/时间                     |

   常用流程控制函数。

   | 函数     | 功能                                             |
   | -------- | ------------------------------------------------ |
   | `IF`     | 根据条件是否成立返回不同的值                     |
   | `IFNULL` | 如果为NULL则返回指定的值否则就返回本身           |
   | `NULLIF` | 两个表达式相等就返回NULL否则返回第一个表达式的值 |

   其他常用函数。

   | 函数                       | 功能                          |
   | -------------------------- | ----------------------------- |
   | `MD5` / `SHA1` / `SHA2`    | 返回字符串对应的哈希摘要      |
   | `CHARSET` / `COLLATION`    | 返回字符集/校对规则           |
   | `USER` / `CURRENT_USER`    | 返回当前用户                  |
   | `DATABASE`                 | 返回当前数据库名              |
   | `VERSION`                  | 返回当前数据库版本            |
   | `FOUND_ROWS` / `ROW_COUNT` | 返回查询到的行数/受影响的行数 |
   | `LAST_INSERT_ID`           | 返回最后一个自增主键的值      |
   | `UUID` / `UUID_SHORT`      | 返回全局唯一标识符            |

### 窗口函数 OLAP

1. 专用窗口函数，包括：`lead`、`lag`、`first_value`、`last_value`、`rank`、`dense_rank`和`row_number`等。
2. 聚合函数，包括：`sum`、`avg`、`max`、`min`和`count`等。

### 视图

视图是关系型数据库中将一组查询指令构成的结果集组合成可查询的数据表的对象。简单的说，视图就是虚拟的表，但与数据表不同的是，数据表是一种实体结构，而视图是一种虚拟结构，你也可以将视图理解为保存在数据库中被赋予名字的 SQL 语句。

1. 可以将实体数据表隐藏起来，让外部程序无法得知实际的数据结构，让访问者可以使用表的组成部分而不是整个表，降低数据库被攻击的风险。
2. 在大多数的情况下视图是只读的（更新视图的操作通常都有诸多的限制），外部程序无法直接透过视图修改数据。
3. 重用 SQL 语句，将高度复杂的查询包装在视图表中，直接访问该视图即可取出需要的数据；也可以将视图视为数据表进行连接查询。
4. 视图可以返回与实体数据表不同格式的数据，在创建视图的时候可以对数据进行格式化处理。

以下类型的视图是不能更新的：

1. 使用了聚合函数（`SUM`、`MIN`、`MAX`、`AVG`、`COUNT`等）、`DISTINCT`、`GROUP BY`、`HAVING`、`UNION`或者`UNION ALL`的视图。
2. `SELECT`中包含了子查询的视图。
3. `FROM`子句中包含了一个不能更新的视图的视图。
4. `WHERE`子句的子查询引用了`FROM`子句中的表的视图。

如果希望更新视图，可以先用`drop`命令删除视图，也可以通过`create or replace view`来更新视图。

视图的规则和限制。

1. 视图可以嵌套，可以利用从其他视图中检索的数据来构造一个新的视图。视图也可以和表一起使用。
2. 创建视图时可以使用`order by`子句，但如果从视图中检索数据时也使用了`order by`，那么该视图中原先的`order by`会被覆盖。
3. 视图无法使用索引，也不会激发触发器（实际开发中因为性能等各方面的考虑，通常不建议使用触发器，所以我们也不对这个概念进行介绍）的执行。

### 函数

函数声明后面的`no sql`是声明函数体并没有使用 SQL 语句；如果函数体中需要通过 SQL 读取数据，需要声明为`reads sql data`。
定义函数前后的`delimiter`命令是为了修改终止符（定界符），因为函数体中的语句都是用`;`表示结束，如果不重新定义定界符，那么遇到的`;`的时候代码就会被截断执行，显然这不是我们想要的效果。

### 过程

过程（又称存储过程）是事先编译好存储在数据库中的一组 SQL 的集合，调用过程可以简化应用程序开发人员的工作，减少与数据库服务器之间的通信，对于提升数据操作的性能也是有帮助的。


### 索引 index

索引的设计原则：

1. **最适合**索引的列是出现在**WHERE子句**和连接子句中的列。
2. 索引列的基数越大（取值多、重复值少），索引的效果就越好。
3. 使用**前缀索引**可以减少索引占用的空间，内存中可以缓存更多的索引。
4. **索引不是越多越好**，虽然索引加速了读操作（查询），但是写操作（增、删、改）都会变得更慢，因为数据的变化会导致索引的更新，就如同书籍章节的增删需要更新目录一样。
5. 使用 InnoDB 存储引擎时，表的普通索引都会保存主键的值，所以**主键要尽可能选择较短的数据类型**，这样可以有效的减少索引占用的空间，提升索引的缓存效果。

### 事务

> 事务（transaction）

当修改多个表的时候，并且这些表的数据是有关联的时候，事务是必须的。要不全部成功，要不全部不成功。

START TRANSACTION 开启事务后所有的 sql 语句都可以 ROLLBACK，除非执行了 COMMIT 完成这段事务。
还可以设置几个 SAVEPOINT，这样可以 ROLLBACK TO 任何一个 SAVEPOINT 的位置

**隔离级别**：主要是数据一致性和性能的差别，一致性越好，并发性能就越差

1、READ UNCOMMITTED：可以读到别的事务尚未提交的数据

- 这个事务内第一次读的数据是 aaa，下次读可能就是 bbb 了，这个问题叫做**不可重复读**。
- 到的就是临时数据，这个问题叫做**脏读**。

2、READ COMMITTED：只读取别的事务已提交的数据。

- 没有脏读问题
- 不可重复读的问题依然存在。不只是数据不一样，可能你两次读取到的记录行数也不一样，这叫做**幻读**。

3、REPEATABLE READ：在同一事务内，多次读取数据将保证结果相同

- 保证了读取到的数据一样，但是不保证行数一样，也就是说解决了不可重复读的问题，但仍然存在幻读的问题。

4、SERIALIZABLE：在同一时间只允许一个事务修改数据。

- 事务一个个执行，各种问题都没有了
- 性能很差，只能一个个的事务执行

### 视图 view

> 视图可以简化查询、控制权限等

### typeorm

具体的 EntityManager 和 Repository 的方法有这些：

save：新增或者修改 Entity，如果传入了 id 会先 select 再决定修改还新增
update：直接修改 Entity，不会先 select
insert：直接插入 Entity
delete：删除 Entity，通过 id
remove：删除 Entity，通过对象
find：查找多条记录，可以指定 where、order by 等条件
findBy：查找多条记录，第二个参数直接指定 where 条件，更简便一点
findAndCount：查找多条记录，并返回总数量
findByAndCount：根据条件查找多条记录，并返回总数量
findOne：查找单条记录，可以指定 where、order by 等条件
findOneBy：查找单条记录，第二个参数直接指定 where 条件，更简便一点
findOneOrFail：查找失败会抛 EntityNotFoundError 的异常
query：直接执行 sql 语句
createQueryBuilder：创建复杂 sql 语句，比如 join 多个 Entity 的查询
transaction：包裹一层事务的 sql
getRepository：拿到对单个 Entity 操作的类，方法同 EntityManager

一对一关系的映射通过 @OneToOne 装饰器来声明，维持外键列的 Entity 添加 @JoinColumn 装饰器。
通过 @OneToOne 装饰器的 onDelete、onUpdate 参数设置级联删除和更新的方式，比如 CASCADE、SET NULL 等。